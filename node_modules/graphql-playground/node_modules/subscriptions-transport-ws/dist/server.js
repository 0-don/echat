"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var WebSocket = require("ws");
var message_types_1 = require("./message-types");
var protocol_1 = require("./protocol");
var isObject = require("lodash.isobject");
var graphql_1 = require("graphql");
var subscription_manager_1 = require("./adapters/subscription-manager");
var empty_iterable_1 = require("./utils/empty-iterable");
var iterall_1 = require("iterall");
var promise_to_iterable_1 = require("./utils/promise-to-iterable");
var is_subscriptions_1 = require("./utils/is-subscriptions");
var parse_legacy_protocol_1 = require("./legacy/parse-legacy-protocol");
var define_deprecation_function_wrapper_1 = require("./legacy/define-deprecation-function-wrapper");
var SubscriptionServer = (function () {
    function SubscriptionServer(options, socketOptions) {
        var _this = this;
        var onSubscribe = options.onSubscribe, onUnsubscribe = options.onUnsubscribe, onOperation = options.onOperation, onOperationComplete = options.onOperationComplete, onConnect = options.onConnect, onDisconnect = options.onDisconnect, keepAlive = options.keepAlive;
        this.specifiedRules = options.validationRules || graphql_1.specifiedRules;
        this.loadExecutor(options);
        this.onOperation = onSubscribe ? onSubscribe : onOperation;
        this.onOperationComplete = onUnsubscribe ? onUnsubscribe : onOperationComplete;
        this.onConnect = onConnect;
        this.onDisconnect = onDisconnect;
        this.keepAlive = keepAlive;
        this.onSubscribe = onSubscribe ?
            define_deprecation_function_wrapper_1.defineDeprecateFunctionWrapper('onSubscribe function is deprecated. Use onOperation instead.') : null;
        this.onUnsubscribe = onUnsubscribe ?
            define_deprecation_function_wrapper_1.defineDeprecateFunctionWrapper('onUnsubscribe function is deprecated. Use onOperationComplete instead.') : null;
        this.wsServer = new WebSocket.Server(socketOptions || {});
        var connectionHandler = (function (socket, request) {
            socket.upgradeReq = request;
            if (socket.protocol === undefined ||
                (socket.protocol.indexOf(protocol_1.GRAPHQL_WS) === -1 && socket.protocol.indexOf(protocol_1.GRAPHQL_SUBSCRIPTIONS) === -1)) {
                socket.close(1002);
                return;
            }
            var connectionContext = Object.create(null);
            connectionContext.isLegacy = false;
            connectionContext.socket = socket;
            connectionContext.operations = {};
            if (_this.keepAlive) {
                var keepAliveTimer_1 = setInterval(function () {
                    if (socket.readyState === WebSocket.OPEN) {
                        _this.sendMessage(connectionContext, undefined, message_types_1.default.GQL_CONNECTION_KEEP_ALIVE, undefined);
                    }
                    else {
                        clearInterval(keepAliveTimer_1);
                    }
                }, _this.keepAlive);
            }
            var connectionClosedHandler = function (error) {
                if (error) {
                    _this.sendError(connectionContext, '', { message: error.message ? error.message : error }, message_types_1.default.GQL_CONNECTION_ERROR);
                    setTimeout(function () {
                        connectionContext.socket.close(1011);
                    }, 10);
                }
                _this.onClose(connectionContext);
                if (_this.onDisconnect) {
                    _this.onDisconnect(socket);
                }
            };
            socket.on('error', connectionClosedHandler);
            socket.on('close', connectionClosedHandler);
            socket.on('message', _this.onMessage(connectionContext));
        });
        this.wsServer.on('connection', connectionHandler);
        this.closeHandler = function () {
            _this.wsServer.removeListener('connection', connectionHandler);
            _this.wsServer.close();
        };
    }
    SubscriptionServer.create = function (options, socketOptions) {
        return new SubscriptionServer(options, socketOptions);
    };
    Object.defineProperty(SubscriptionServer.prototype, "server", {
        get: function () {
            return this.wsServer;
        },
        enumerable: true,
        configurable: true
    });
    SubscriptionServer.prototype.close = function () {
        this.closeHandler();
    };
    SubscriptionServer.prototype.loadExecutor = function (options) {
        var subscriptionManager = options.subscriptionManager, execute = options.execute, subscribe = options.subscribe, schema = options.schema, rootValue = options.rootValue;
        if (!subscriptionManager && !execute) {
            throw new Error('Must provide `subscriptionManager` or `execute` to websocket server constructor.');
        }
        if (subscriptionManager && execute) {
            throw new Error('Must provide `subscriptionManager` or `execute` and not both.');
        }
        if (subscribe && !execute) {
            throw new Error('Must provide `execute` when providing `subscribe`!');
        }
        if (execute && !schema) {
            throw new Error('Must provide `schema` when using `execute`.');
        }
        if (subscriptionManager) {
            console.warn('subscriptionManager is deprecated, use `execute` or `subscribe` directly from `graphql-js`!');
        }
        this.schema = schema;
        this.rootValue = rootValue;
        if (subscriptionManager) {
            this.execute = subscription_manager_1.executeFromSubscriptionManager(subscriptionManager);
        }
        else {
            this.execute = execute;
            this.subscribe = subscribe;
        }
    };
    SubscriptionServer.prototype.unsubscribe = function (connectionContext, opId) {
        if (connectionContext.operations && connectionContext.operations[opId]) {
            if (connectionContext.operations[opId].return) {
                connectionContext.operations[opId].return();
            }
            delete connectionContext.operations[opId];
            if (this.onOperationComplete) {
                this.onOperationComplete(connectionContext.socket, opId);
            }
        }
    };
    SubscriptionServer.prototype.onClose = function (connectionContext) {
        var _this = this;
        Object.keys(connectionContext.operations).forEach(function (opId) {
            _this.unsubscribe(connectionContext, opId);
        });
    };
    SubscriptionServer.prototype.onMessage = function (connectionContext) {
        var _this = this;
        var onInitResolve = null, onInitReject = null;
        connectionContext.initPromise = new Promise(function (resolve, reject) {
            onInitResolve = resolve;
            onInitReject = reject;
        });
        return function (message) {
            var parsedMessage;
            try {
                parsedMessage = parse_legacy_protocol_1.parseLegacyProtocolMessage(connectionContext, JSON.parse(message));
            }
            catch (e) {
                _this.sendError(connectionContext, null, { message: e.message }, message_types_1.default.GQL_CONNECTION_ERROR);
                return;
            }
            var opId = parsedMessage.id;
            switch (parsedMessage.type) {
                case message_types_1.default.GQL_CONNECTION_INIT:
                    var onConnectPromise = Promise.resolve(true);
                    if (_this.onConnect) {
                        onConnectPromise = new Promise(function (resolve, reject) {
                            try {
                                resolve(_this.onConnect(parsedMessage.payload, connectionContext.socket, connectionContext));
                            }
                            catch (e) {
                                reject(e);
                            }
                        });
                    }
                    onInitResolve(onConnectPromise);
                    connectionContext.initPromise.then(function (result) {
                        if (result === false) {
                            throw new Error('Prohibited connection!');
                        }
                        _this.sendMessage(connectionContext, undefined, message_types_1.default.GQL_CONNECTION_ACK, undefined);
                        if (_this.keepAlive) {
                            _this.sendMessage(connectionContext, undefined, message_types_1.default.GQL_CONNECTION_KEEP_ALIVE, undefined);
                        }
                    }).catch(function (error) {
                        _this.sendError(connectionContext, opId, { message: error.message }, message_types_1.default.GQL_CONNECTION_ERROR);
                        setTimeout(function () {
                            connectionContext.socket.close(1011);
                        }, 10);
                    });
                    break;
                case message_types_1.default.GQL_CONNECTION_TERMINATE:
                    connectionContext.socket.close();
                    break;
                case message_types_1.default.GQL_START:
                    connectionContext.initPromise.then(function (initResult) {
                        if (connectionContext.operations && connectionContext.operations[opId]) {
                            _this.unsubscribe(connectionContext, opId);
                        }
                        var baseParams = {
                            query: parsedMessage.payload.query,
                            variables: parsedMessage.payload.variables,
                            operationName: parsedMessage.payload.operationName,
                            context: Object.assign({}, isObject(initResult) ? initResult : {}),
                            formatResponse: undefined,
                            formatError: undefined,
                            callback: undefined,
                        };
                        var promisedParams = Promise.resolve(baseParams);
                        connectionContext.operations[opId] = empty_iterable_1.createEmptyIterable();
                        if (_this.onOperation) {
                            var messageForCallback = parsedMessage;
                            if (_this.onSubscribe) {
                                messageForCallback = parsedMessage.payload;
                            }
                            promisedParams = Promise.resolve(_this.onOperation(messageForCallback, baseParams, connectionContext.socket));
                        }
                        promisedParams.then(function (params) {
                            if (typeof params !== 'object') {
                                var error = "Invalid params returned from onOperation! return values must be an object!";
                                _this.sendError(connectionContext, opId, { message: error });
                                throw new Error(error);
                            }
                            var document = typeof baseParams.query !== 'string' ? baseParams.query : graphql_1.parse(baseParams.query);
                            var executionIterable;
                            var validationErrors = [];
                            if (_this.schema) {
                                validationErrors = graphql_1.validate(_this.schema, document, _this.specifiedRules);
                            }
                            if (validationErrors.length > 0) {
                                executionIterable = promise_to_iterable_1.createIterableFromPromise(Promise.resolve({ errors: validationErrors }));
                            }
                            else if (_this.subscribe && is_subscriptions_1.isASubscriptionOperation(document, params.operationName)) {
                                executionIterable = _this.subscribe(_this.schema, document, _this.rootValue, params.context, params.variables, params.operationName);
                            }
                            else {
                                var promiseOrIterable = _this.execute(_this.schema, document, _this.rootValue, params.context, params.variables, params.operationName);
                                if (!iterall_1.isAsyncIterable(promiseOrIterable) && promiseOrIterable instanceof Promise) {
                                    executionIterable = promise_to_iterable_1.createIterableFromPromise(promiseOrIterable);
                                }
                                else if (iterall_1.isAsyncIterable(promiseOrIterable)) {
                                    executionIterable = promiseOrIterable;
                                }
                                else {
                                    console.error('Invalid `execute` return type! Only Promise or AsyncIterable are valid values!');
                                    _this.sendError(connectionContext, opId, {
                                        message: 'GraphQL execute engine is not available',
                                    });
                                }
                            }
                            iterall_1.forAwaitEach(iterall_1.createAsyncIterator(executionIterable), function (value) {
                                var result = value;
                                if (params.formatResponse) {
                                    try {
                                        result = params.formatResponse(value, params);
                                    }
                                    catch (err) {
                                        console.error('Error in formatError function:', err);
                                    }
                                }
                                _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_DATA, result);
                            })
                                .then(function () {
                                _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_COMPLETE, null);
                            })
                                .catch(function (e) {
                                var error = e;
                                if (params.formatError) {
                                    try {
                                        error = params.formatError(e, params);
                                    }
                                    catch (err) {
                                        console.error('Error in formatError function: ', err);
                                    }
                                }
                                if (Object.keys(e).length === 0) {
                                    error = { name: e.name, message: e.message };
                                }
                                _this.sendError(connectionContext, opId, error);
                            });
                            return executionIterable;
                        }).then(function (subscription) {
                            connectionContext.operations[opId] = subscription;
                        }).then(function () {
                            _this.sendMessage(connectionContext, opId, message_types_1.default.SUBSCRIPTION_SUCCESS, undefined);
                        }).catch(function (e) {
                            if (e.errors) {
                                _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_DATA, { errors: e.errors });
                            }
                            else {
                                _this.sendError(connectionContext, opId, { message: e.message });
                            }
                            _this.unsubscribe(connectionContext, opId);
                            return;
                        });
                    });
                    break;
                case message_types_1.default.GQL_STOP:
                    connectionContext.initPromise.then(function () {
                        _this.unsubscribe(connectionContext, opId);
                    });
                    break;
                default:
                    _this.sendError(connectionContext, opId, { message: 'Invalid message type!' });
            }
        };
    };
    SubscriptionServer.prototype.sendMessage = function (connectionContext, opId, type, payload) {
        var parsedMessage = parse_legacy_protocol_1.parseLegacyProtocolMessage(connectionContext, {
            type: type,
            id: opId,
            payload: payload,
        });
        if (parsedMessage && connectionContext.socket.readyState === WebSocket.OPEN) {
            connectionContext.socket.send(JSON.stringify(parsedMessage));
        }
    };
    SubscriptionServer.prototype.sendError = function (connectionContext, opId, errorPayload, overrideDefaultErrorType) {
        var sanitizedOverrideDefaultErrorType = overrideDefaultErrorType || message_types_1.default.GQL_ERROR;
        if ([
            message_types_1.default.GQL_CONNECTION_ERROR,
            message_types_1.default.GQL_ERROR,
        ].indexOf(sanitizedOverrideDefaultErrorType) === -1) {
            throw new Error('overrideDefaultErrorType should be one of the allowed error messages' +
                ' GQL_CONNECTION_ERROR or GQL_ERROR');
        }
        this.sendMessage(connectionContext, opId, sanitizedOverrideDefaultErrorType, errorPayload);
    };
    return SubscriptionServer;
}());
exports.SubscriptionServer = SubscriptionServer;
//# sourceMappingURL=server.js.map